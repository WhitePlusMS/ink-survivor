# 更新说明

## 2025-02-18

### 问题1：大纲版本不显示

#### 问题描述
用户点击"作品大纲"时，发现大纲版本不显示。

#### 原因分析
- 数据库已有 `BookOutlineVersion` 表存储大纲版本
- 后端 API 已正确返回 `outlineVersions` 数据
- 前端组件 `outline-display.tsx` 的版本选择器只在 `versions.length > 1` 时才显示
- 导致只有一个版本(V1)时，版本信息完全不显示

#### 修改内容
**文件**: `src/components/book/outline-display.tsx`

1. **修改版本选择器显示逻辑**：
   - 原来：`versions.length > 1` 时才显示
   - 修改为：`versions.length > 0` 时就显示版本信息

2. **版本显示逻辑优化**：
   - 多个版本(>1)：显示下拉选择器，可切换不同版本
   - 多个版本(=1)：直接显示"第 X 版"文本

3. **修复历史版本提示显示条件**：
   - 增加 `!loadingVersion` 条件，避免加载中时显示提示

#### 影响范围
- 前端组件 `OutlineDisplay`
- 大纲展示功能

#### 测试建议
1. 检查只有一个版本(V1)的书籍，大纲是否显示"第 1 版"
2. 检查有多个版本(V1、V2、V3...)的书籍，是否可以切换查看不同版本

---

### 问题2：章节缺失（第1、2章丢失）

#### 问题描述
书籍《罗汉果的救赎》大纲有1-5章，但实际只有3、4、5章，第1、2章缺失。

#### 原因分析
原 `catchUpBooks` 追赶逻辑假设章节是连续编号的（1,2,3...），使用 `book._count.chapters` 计算缺失章节：
- 当前有3章，假设是第1、2、3章
- 目标轮次5，只计算 `5 - 3 = 2`，生成第4、5章
- 但实际上第1、2章已经缺失！

#### 修改内容
**文件**: `src/services/chapter-writing.ts`

1. **获取实际章节编号**：
   - 从数据库获取书籍实际拥有的章节编号
   - 使用 `Set` 存储以便快速查找

2. **计算真正缺失的章节**：
   - 遍历1到targetRound，检测每个章节是否存在
   - 生成缺失章节列表 `[1, 2, ...]`

3. **检测大纲是否包含缺失章节**：
   - 检查大纲中是否有缺失章节的 Outline
   - 如果没有，先生成对应章节的大纲

4. **按章节顺序补写**：
   - 对缺失章节按顺序执行补写

#### 影响范围
- 章节追赶生成逻辑
- 未来所有赛季书籍的章节补齐

#### 测试建议
- 对《罗汉果的救赎》执行追赶测试，验证是否能补齐第1、2章

---

### 问题3：书籍详情页添加章节补全功能

#### 需求描述
在书籍详情页添加一个"补全章节"按钮，只有书籍的Agent作者登录时才可见。点击后：
1. 检测当前书籍是否缺少章节（基于最新大纲）
2. 如果缺少，则调用追赶函数补全缺失章节
3. 前端按钮需要防抖、加载状态、不可选中样式

#### 修改内容

**新增文件**:
1. `src/app/api/books/[id]/catch-up/route.ts` - 后端API接口
   - POST: 检查并补全章节
   - GET: 获取章节补全状态

2. `src/components/book/catch-up-button.tsx` - 前端按钮组件
   - 首次加载时获取章节状态
   - 防抖：点击后按钮禁用，避免重复请求
   - 加载状态：显示"补全中..."和加载动画
   - 结果反馈：显示成功或错误信息
   - 章节状态：显示当前章节、大纲章节、赛季轮次

**修改文件**:
1. `prisma/schema.prisma` - Book 表添加 `isCatchingUp` 字段

#### 影响范围
- 书籍详情页
- 章节补全功能

#### 测试建议
1. 以 Agent 作者身份登录，访问自己创建的书籍详情页
2. 检查是否显示"补全章节"按钮
3. 点击按钮，验证是否能补全缺失章节

---

### 问题4：章节补全功能接入任务队列系统（本次更新）

#### 问题描述
原补全章节功能使用 `setTimeout` + `isCatchingUp` 字段的方案存在以下问题：
- 服务器重启时任务会丢失，但状态可能卡在"补全中"
- 没有任务重试机制
- 无法追踪任务状态
- 没有超时机制

#### 原因分析
项目已有完善的任务队列系统（TaskQueue + TaskWorker），但补全功能没有使用它，而是自己实现了一套简单但不可靠的方案。

#### 修改内容

**1. 新增任务类型 `CATCH_UP_SINGLE`**
- 文件: `src/services/task-queue.service.ts`
- 添加 `CATCH_UP_SINGLE` 任务类型，用于单本书章节补全

**2. 添加任务处理器**
- 文件: `src/services/task-worker.service.ts`
- 新增 `CATCH_UP_SINGLE` 任务处理逻辑
- 调用 `chapterWritingService.catchUpSingleBook()` 执行补全

**3. 修改 API 使用任务队列**
- 文件: `src/app/api/books/[id]/catch-up/route.ts`
- 移除 `setTimeout` + `isCatchingUp` 的不可靠方案
- 改用 `taskQueueService.create()` 创建任务
- 防重机制改为查询任务队列中的 PENDING/PROCESSING 任务
- GET 接口的 `isCatchingUp` 状态也改为从任务队列获取

#### 修改前后对比

| 方面 | 修改前 | 修改后 |
|------|--------|--------|
| 任务执行 | setTimeout (不可靠) | 任务队列 (可靠) |
| 防重机制 | isCatchingUp 字段 | 查询 PENDING/PROCESSING 任务 |
| 状态追踪 | 字段可能卡住 | 任务状态实时更新 |
| 失败重试 | 无 | 最多3次重试 |
| 任务丢失 | 服务器重启丢失 | 自动重试恢复 |

#### 影响范围
- 章节补全 API
- 任务队列系统
- 前端状态显示（isCatchingUp 仍从 API 获取）

#### 测试建议
1. 触发章节补全，验证任务是否正确创建到 TaskQueue 表
2. 观察 TaskWorker 是否正确执行任务
3. 检查任务完成后状态是否正确变为 COMPLETED
4. 模拟失败场景，验证重试机制是否生效

#### 后续可选优化
- 删除 `prisma/schema.prisma` 中的 `isCatchingUp` 字段（目前前端通过 API 获取状态，字段已无实际作用）

---

### 问题4：撤销章节补全接入任务队列（本次更新）

#### 问题描述
之前尝试将用户手动触发的章节补全功能接入任务队列系统，但经过讨论决定：

- **CATCH_UP**：赛季自动流程的一部分，ROUND_CYCLE 结束后自动触发，保留在任务队列
- **CATCH_UP_SINGLE**：用户手动点击按钮触发的独立任务，**不应该**接入任务队列

用户手动触发的任务应该保持简单独立，不混入赛季自动流程。

#### 修改内容（撤销）

**1. 撤销 task-queue.service.ts**
- 删除 `CATCH_UP_SINGLE` 任务类型

**2. 撤销 task-worker.service.ts**
- 删除 `CATCH_UP_SINGLE` 任务处理逻辑

**3. 恢复 catch-up API**
- 改回使用 `setTimeout` + `isCatchingUp` 字段的方案
- 用户点击按钮时设置 `isCatchingUp = true`
- 异步执行补全任务，完成后重置为 `false`

#### 设计决策
- 补全任务是用户手动触发的独立任务，不需要任务队列的重试机制
- 简单方案：用户点击 → setTimeout 异步执行 → 完成后重置状态
- 如遇服务器重启导致状态卡住，需手动在数据库将 `isCatchingUp` 重置为 `false`
